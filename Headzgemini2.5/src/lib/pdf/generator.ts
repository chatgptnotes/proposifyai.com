import jsPDF from 'jspdf';
import html2canvas from 'html2canvas';
import { Proposal, formatCurrency } from '../proposals/validation';
import { format } from 'date-fns';

export interface PDFOptions {
  includeHeader?: boolean;
  includeFooter?: boolean;
  includePageNumbers?: boolean;
  brandingLogo?: string;
  brandingColor?: string;
  watermark?: string;
}

export interface PDFGenerationResult {
  success: boolean;
  blob?: Blob;
  error?: string;
}

// Generate PDF from proposal data
export async function generateProposalPDF(
  proposal: Proposal,
  options: PDFOptions = {}
): Promise<PDFGenerationResult> {
  try {
    const {
      includeHeader = true,
      includeFooter = true,
      includePageNumbers = true,
      brandingColor = '#4F46E5',
    } = options;

    const pdf = new jsPDF({
      orientation: 'portrait',
      unit: 'mm',
      format: 'a4',
    });

    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    const margin = 20;
    let yPosition = margin;

    // Add header
    if (includeHeader) {
      pdf.setFillColor(brandingColor);
      pdf.rect(0, 0, pageWidth, 40, 'F');

      pdf.setTextColor(255, 255, 255);
      pdf.setFontSize(24);
      pdf.text('PROPOSAL', margin, 25);

      yPosition = 50;
    }

    // Add proposal title
    pdf.setTextColor(0, 0, 0);
    pdf.setFontSize(20);
    pdf.text(proposal.title, margin, yPosition);
    yPosition += 15;

    // Add metadata
    pdf.setFontSize(10);
    pdf.setTextColor(100, 100, 100);

    const metadataLines = [
      `Client: ${proposal.clientName}`,
      `Amount: ${formatCurrency(proposal.amount, proposal.currency)}`,
      `Date: ${format(new Date(proposal.createdAt), 'MMMM dd, yyyy')}`,
    ];

    if (proposal.expiresAt) {
      metadataLines.push(`Expires: ${format(new Date(proposal.expiresAt), 'MMMM dd, yyyy')}`);
    }

    metadataLines.forEach(line => {
      pdf.text(line, margin, yPosition);
      yPosition += 6;
    });

    yPosition += 10;

    // Add divider line
    pdf.setDrawColor(200, 200, 200);
    pdf.line(margin, yPosition, pageWidth - margin, yPosition);
    yPosition += 10;

    // Add content
    pdf.setFontSize(11);
    pdf.setTextColor(0, 0, 0);

    const contentLines = pdf.splitTextToSize(
      proposal.content,
      pageWidth - (margin * 2)
    );

    contentLines.forEach((line: string) => {
      if (yPosition > pageHeight - 40) {
        pdf.addPage();
        yPosition = margin;
      }
      pdf.text(line, margin, yPosition);
      yPosition += 7;
    });

    // Add footer
    const totalPages = pdf.getNumberOfPages();

    for (let i = 1; i <= totalPages; i++) {
      pdf.setPage(i);

      if (includeFooter) {
        pdf.setFontSize(8);
        pdf.setTextColor(150, 150, 150);

        const footerY = pageHeight - 15;
        pdf.text('Generated by ProposifyAI', margin, footerY);

        if (includePageNumbers) {
          const pageText = `Page ${i} of ${totalPages}`;
          const pageTextWidth = pdf.getTextWidth(pageText);
          pdf.text(pageText, pageWidth - margin - pageTextWidth, footerY);
        }
      }
    }

    // Convert to blob
    const blob = pdf.output('blob');

    return {
      success: true,
      blob,
    };
  } catch (error) {
    console.error('PDF generation error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error occurred',
    };
  }
}

// Generate PDF from HTML element
export async function generatePDFFromHTML(
  element: HTMLElement,
  filename: string = 'proposal.pdf',
  options: PDFOptions = {}
): Promise<PDFGenerationResult> {
  try {
    const canvas = await html2canvas(element, {
      scale: 2,
      useCORS: true,
      logging: false,
      backgroundColor: '#ffffff',
    });

    const imgData = canvas.toDataURL('image/png');
    const pdf = new jsPDF({
      orientation: 'portrait',
      unit: 'mm',
      format: 'a4',
    });

    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();

    const imgWidth = pageWidth;
    const imgHeight = (canvas.height * pageWidth) / canvas.width;

    let heightLeft = imgHeight;
    let position = 0;

    // Add first page
    pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
    heightLeft -= pageHeight;

    // Add additional pages if needed
    while (heightLeft > 0) {
      position = heightLeft - imgHeight;
      pdf.addPage();
      pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
      heightLeft -= pageHeight;
    }

    // Add page numbers if requested
    if (options.includePageNumbers) {
      const totalPages = pdf.getNumberOfPages();
      for (let i = 1; i <= totalPages; i++) {
        pdf.setPage(i);
        pdf.setFontSize(8);
        pdf.setTextColor(150, 150, 150);
        const pageText = `Page ${i} of ${totalPages}`;
        const pageTextWidth = pdf.getTextWidth(pageText);
        pdf.text(pageText, pageWidth - 20 - pageTextWidth, pageHeight - 10);
      }
    }

    const blob = pdf.output('blob');

    return {
      success: true,
      blob,
    };
  } catch (error) {
    console.error('PDF generation from HTML error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error occurred',
    };
  }
}

// Download PDF
export function downloadPDF(blob: Blob, filename: string = 'proposal.pdf'): void {
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

// Convert PDF blob to base64
export async function blobToBase64(blob: Blob): Promise<string> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => {
      const result = reader.result as string;
      resolve(result);
    };
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}

// Get PDF file size in MB
export function getPDFSize(blob: Blob): number {
  return blob.size / (1024 * 1024);
}

// Validate PDF size
export function validatePDFSize(blob: Blob, maxSizeMB: number = 10): boolean {
  const sizeMB = getPDFSize(blob);
  return sizeMB <= maxSizeMB;
}
